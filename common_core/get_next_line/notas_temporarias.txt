// strljoin(char *dest, char *src)
// {
// 	char *e;

// 	LEN_DEST/*(ate \0)*/= 9
// 	SRC_LEN/*(ate \n se nao tiver, ate \0)*/ = 9
// 	e = malloc(18+1);
// 	strlcat(e, dest, LEN_DEST);
// 	strlcat(e, src, SRC_LEN);
// 	free(dest);
	
// 	return e;
	
// }

// char *get_next_line(int fd)
// {
// 	static char buf[BUFFER_SIZE + 1];
// 	int chars_read;
// 	char *next_line;
	
// 	next_line = NULL;
// 	chars_read = read(fd, buf, BUFFER_SIZE);
//     next_line = strljoin(next_line, buf);
	
// 	buf[chars_read] = '\0';
//     next_line = buf;
// 	return (next_line);
// }

char *get_next_line(int fd)
{
	static char buf[BUFFER_SIZE + 1];
	
	read(fd, buf, BUFFER_SIZE);
	
	
}

int main()
{
	int fd;
	fd = open("text.txt", O_RDONLY);
	char *next_line;
	next_line = get_next_line(fd);
	printf("%s\n", next_line);
}


// int main()
// {
//     int fd;
//     char buf[256];
//     int chars_read;
//     fd = open("text2.txt", O_RDONLY);
    
//     while ((chars_read = read(fd, buf, 1)))
//     {
//         buf[chars_read] = '\0';
//         printf("%s\n", buf);
//     }


//     write(1, "\n", 1);
//     return 0;
// }



// char *get_next_line(int fd)
// {
// 	char buf[BUFFER_SIZE];
// 	int chars_read;
// 	char *next_line;
	
	
// 	chars_read = read(fd, buf, BUFFER_SIZE);
//     buf[chars_read] = '\0';
    
//     next_line = buf;
// 	return (next_line);
// }
/*
	1. iniciar o buffer;
	2. verificar se buffer tem algo dentro {if (buffer[0])}
	3. se nao tiver, ler do ficheiro e verificar se leu bem.
	4. strjoin que alloca memoria baseado no buffer ter \n ou \0
	4.2 limpar o resto metendo no inicio do buffer
*/



/*
stu\nde\0 nt
ola\0

buf = nt
*/









----------------------------------------------------------------------------------------------------------------------------------



size_t	ft_strlen(const char *s)
{
	size_t	i;

	i = 0;
	while (s[i])
		i++;
	return (i);
}

char	*ft_strchr(const char *s, int c)
{
	int	i;

	i = 0;
	while (s[i] != '\0')
	{
		if (s[i] == (char)c)
			return ((char *)&s[i]);
		else
			i++;
	}
	if (s[i] == '\0' && (char)c == '\0')
		return ((char *)&s[i]);
	return (NULL);
}
size_t	ft_strlcat(char *dest, const char *src, size_t size)
{
	unsigned int	i;
	unsigned int	j;
	size_t			src_len;
	size_t			dest_len;

	src_len = ft_strlen(src);
	if (size == 0)
		return (src_len);
	dest_len = ft_strlen(dest);
	if (size <= dest_len)
		return (src_len + size);
	i = dest_len;
	j = 0;
	while (i < size - 1 && src[j] != '\0')
	{
		dest[i] = src[j];
		i++;
		j++;
	}
	dest[i] = '\0';
	return (src_len + dest_len);
}

char *get_next_line(int fd)
{
	static char buf[BUFFER_SIZE + 1];
	
	read(fd, buf, BUFFER_SIZE);
	
	char *next_line;
	char *next_line_temp;
	next_line_temp = buf;
	
	int i;
	i = 0;
	while(next_line_temp[i] != '\n')
		i++;
	ft_strlcat(next_line, next_line, i);
	// next_line = ft_strchr(next_line, '\n');
	
	return (next_line);
}

int main()
{
	int fd;
	fd = open("text.txt", O_RDONLY);
	char *next_line;
	next_line = get_next_line(fd);
	printf("%s\n", next_line);
}



// char *get_next_line(int fd)
// {
// 	char buf[BUFFER_SIZE];
// 	int chars_read;
// 	char *next_line;
	
	
// 	chars_read = read(fd, buf, BUFFER_SIZE);
//     buf[chars_read] = '\0';
    
//     next_line = buf;
// 	return (next_line);
// }
/*
	1. iniciar o buffer;
	2. verificar se buffer tem algo dentro {if (buffer[0])}
	3. se nao tiver, ler do ficheiro e verificar se leu bem.
	4. strjoin que alloca memoria baseado no buffer ter \n ou \0
	4.2 limpar o resto metendo no inicio do buffer
*/

// strljoin(char *dest, char *src)
// {
// 	char *e;

// 	LEN_DEST/*(ate \0)*/= 9
// 	SRC_LEN/*(ate \n se nao tiver, ate \0)*/ = 9
// 	e = malloc(18+1);
// 	strlcat(e, dest, LEN_DEST);
// 	strlcat(e, src, SRC_LEN);
// 	free(dest);
	
// 	return e;
	
// }

// char *get_next_line(int fd)
// {
// 	static char buf[BUFFER_SIZE + 1];
// 	int chars_read;
// 	char *next_line;
	
// 	next_line = NULL;
// 	chars_read = read(fd, buf, BUFFER_SIZE);
//     next_line = strljoin(next_line, buf);
	
// 	buf[chars_read] = '\0';
//     next_line = buf;
// 	return (next_line);
// }

/*
stu\nde\0 nt
ola\0

buf = nt
*/